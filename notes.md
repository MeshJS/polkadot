how would wallet init look?

```
import { PolkaDotProvider } from '@meshsdk/core'

/*
Polkadot provider could be something as simple as https://github.com/MeshJS/mesh/commit/282bb19815788df0ce600ec05d858376b0a5933a#diff-bade6eed458bbe5df0026a1bb4e1c36207ab4625788aeed37a17599a7b558dacR4-R24

essentially just forwarding to wsProvider by polkadot.js
*/
const provider = new PolkaDotProvider('wss://rpc.polkadot.io')

const wallet = new MeshWallet({
  networkId: // ? This does make sense in the context of dot
  fetcher: provider,
  submitter: provider,
  key: // ? what do we put here. need some way to interface with polkadot.js keyring. cfr. https://polkadot.js.org/docs/api/start/keyring#adding-accounts we need to pass the keyringPair generated by keyring.addFrom* to sign
})
```

## CIP-30 comparison

```
In the following `api` would be an instance of a connected polkadot.js api
```

methods:

- wallet.getBalance(address?)

With no argument returns wallet own balance. Optional argument to fetch balance for different account.
Calls `api.derive.balances.all` (or `api.derive.balances.account`?).

- wallet.getAccount(address)

Can be used to resolve different address formats to its corresponding accountId. Called with no args return wallet own account (provided by key in initialisation).

Note: In CIP-30 we have getUsedAddresses/getUnusedAddresses, getChangeAddress and getRewardAddresses

I don't think the used/unused distinction can be made in polkadot. There are derivations, i.e. multiple accounts that can be generated by the same "root key" (mnemonic, maybe something else?).

getChangeAddress does not apply either as there are no utxos, thus no change.

see below for getRewardAddresses

- wallet.getNetworkId()

This doesn't make sense in polkadot? Maybe return parachain we are connected to?

- wallet.getRewardAddresses?

Addresses don't have a staking component as in cardano. Generally it is recommended to split staking in 2 accounts: stash and proxy (cfr. https://wiki.polkadot.network/docs/learn-staking#stash-account-and-staking-proxy) the idea is stash holds the funds bonded for staking (remember, staking is not liquid on polkadot cfr. https://polkadot.meshjs.dev/en/wiki/1_theory_and_comparison/1002), but delegates all staking decisions to a proxy account.
Not sure what we could do here, you would need to instantiate the meshJs wallet once with the stash key and once with the proxy. We could link them somehow, but then this defeats the point of splitting them?

- wallet.signData

cfr. https://polkadot.js.org/docs/extension/cookbook#sign-a-message

- wallet.signTx / wallet.submitTx

cfr. https://polkadot.js.org/docs/extension/cookbook#sign-and-send-a-transaction

does not seem to offer interface to sign and submit separately?

This does not depend on a pallet. All the endpoints are decorated with the `signAndSubmit` method (this is why you can do `tx.balances.transfer(..).signAndSubmit` even though this is not a method of the balances pallet) 
